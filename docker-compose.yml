# =======================================================================================
# DOCKER COMPOSE — GUIA COMENTADO PARA INICIANTES
# ---------------------------------------------------------------------------------------
# Pense neste arquivo como um “roteiro de montagem” do seu ambiente. Ele descreve,
# em YAML, quais serviços existem (banco, apps, proxy), quais imagens usar, quais
# portas abrir, quais variáveis de ambiente definir, como verificar se cada serviço
# está saudável e como todos se conectam por uma rede interna automática.
# Leia os comentários de cima para baixo: cada bloco explica, com calma, o papel
# de cada linha logo abaixo — assim você entende o QUE faz e POR QUE existe.
# =======================================================================================

# A chave raiz `services` lista cada contêiner que compõe o sistema. O Docker Compose
# cria uma rede interna para eles conversarem entre si usando o NOME do serviço.
services:

  # =============================================================================
  # SERVIÇO: POSTGRES (BANCO DE DADOS)
  # Este contêiner guarda dados de forma persistente (via volume) e expõe a porta
  # do PostgreSQL. O bloco também mostra como “injetar” um script SQL inicial e
  # como checar se o banco está realmente pronto antes de outras partes usarem.
  # =============================================================================
  postgres:
    # A imagem base é “postgres:15-alpine”: Postgres 15 sobre Alpine Linux (bem leve).
    image: postgres:15-alpine

    # Nome fixo do contêiner facilita logs/diagnósticos (aparece em `docker ps`).
    container_name: postgres

    # Política de reinício: se cair, o Docker tenta levantar de novo automaticamente.
    restart: always

    # Variáveis de ambiente consumidas pela imagem oficial para configuração inicial
    # (usuário, senha, banco padrão). Em desenvolvimento, isso agiliza o setup.
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres_api_db
      # Atenção: HOST_AUTH_METHOD=trust desativa exigência de senha na rede interna
      # do Compose. É prático para testes, mas NÃO use em produção.
      POSTGRES_HOST_AUTH_METHOD: trust

    # Volumes persistem dados fora do contêiner. Mesmo que o contêiner seja removido,
    # as tabelas permanecem no volume “pgdata”. Também montamos um SQL inicial.
    volumes:
      - pgdata:/var/lib/postgresql/data
      # O arquivo `sql/init.sql` roda na primeira criação do banco (entrypoint do Postgres
      # procura scripts em /docker-entrypoint-initdb.d/). O sufixo :ro monta como leitura.
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql:ro

    # Limites de CPU e memória ajudam a simular um ambiente restrito. Em Compose “puro”,
    # use o modo compatibilidade; em Swarm, esses limites são aplicados nativamente.
    deploy:
      resources:
        limits:
          cpus: "0.80"
          memory: "250MB"

    # Mapeamento de portas: 5433 (seu PC) -> 5432 (dentro do contêiner). Assim você
    # evita conflito com um Postgres local que já use 5432.
    ports:
      - "5433:5432"

    # Healthcheck: receita para o Docker saber quando o banco está REALMENTE pronto.
    # Aqui verificamos se a tabela _init_done (criada ao final do seu init.sql) existe.
    healthcheck:
      test: [ "CMD-SHELL", "psql -U postgres -d postgres_api_db -tAc \"SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = '_init_done'\" | grep -q 1 && sleep 2" ]
      interval: "5s"
      timeout: "5s"
      retries: 10
      start_period: "10s"

  # =============================================================================
  # SERVIÇO: APP1 (INSTÂNCIA DA APLICAÇÃO)
  # A aplicação é construída a partir de um Dockerfile próprio e parametrizada via
  # variáveis de ambiente para achar o banco. “expose” publica a porta apenas na
  # rede interna (Nginx enxerga), e um healthcheck HTTP confirma se a rota responde.
  # =============================================================================
  app1:
    # O Compose vai construir a imagem localmente usando o Dockerfile indicado.
    build:
      context: .
      dockerfile: ./app/Dockerfile
      # Flag comum para builds mais rápidos em pipelines (cache inline do BuildKit).
      args:
        BUILDKIT_INLINE_CACHE: 1
    container_name: app1

    # Variáveis usadas pelo código da aplicação para expor porta e conectar ao banco.
    # Repare que DB_HOST é “postgres”: é o nome do serviço, resolvido via DNS interno.
    environment:
      PORT: 3001
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: postgres
      DB_PASSWORD: postgres
      DB_DATABASE: postgres_api_db
      PG_MIN: 5
      PG_MAX: 10
      HOSTNAME: app1

    # `expose` NÃO abre a porta para fora do host; apenas torna a 3001 visível na rede
    # interna do Compose (para o Nginx e outros serviços).
    expose:
      - "3001"

    # Healthcheck HTTP simples: faz GET num endpoint da própria API. O `sleep` serve
    # como pequeno respiro antes/depois da tentativa, reduzindo falsos negativos.
    healthcheck:
      test: [ "CMD-SHELL", "sleep 2 && curl -f http://localhost:$$PORT/clientes/1/extrato || exit 1 && sleep 2" ]
      interval: "5s"
      timeout: "5s"
      retries: 60
      start_period: "60s"

    # Garante que a app só tente subir depois de o Postgres estar “saudável”.
    depends_on:
      postgres:
        condition: service_healthy

    # Limites de recursos para a app — úteis em benchmarks comparáveis.
    deploy:
      resources:
        limits:
          cpus: "0.25"
          memory: "100MB"

    restart: always             # Política de reinício automática: se o container parar/crashar, o Docker tenta subir novamente.

  # =============================================================================
  # SERVIÇO: APP2 (SEGUNDA INSTÂNCIA DA APLICAÇÃO)
  # Clonar a app em outra porta (3002) permite que o Nginx faça balanceamento de
  # carga entre app1 e app2. Isso melhora throughput e resiliência.
  # =============================================================================
  app2:
    build:
      context: .
      dockerfile: ./app/Dockerfile
      args:
        BUILDKIT_INLINE_CACHE: 1
    container_name: app2
    environment:
      PORT: 3002
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: postgres
      DB_PASSWORD: postgres
      DB_DATABASE: postgres_api_db
      PG_MIN: 5
      PG_MAX: 10
      HOSTNAME: app2
    expose:
      - "3002"
    healthcheck:
      test: [ "CMD-SHELL", "sleep 2 && curl -f http://localhost:$$PORT/clientes/1/extrato || exit 1 && sleep 2" ]
      interval: "5s"
      timeout: "5s"
      retries: 60
      start_period: "60s"
    depends_on:
      postgres:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: "0.25"
          memory: "100MB"
    restart: always             # Política de reinício automática: se o container parar/crashar, o Docker tenta subir novamente.

  # =============================================================================
  # SERVIÇO: NGINX (REVERSE PROXY / BALANCEADOR)
  # O Nginx é a “porta de entrada” do sistema: recebe tráfego externo (porta 9999)
  # e distribui para app1/app2. O arquivo nginx.conf, montado via volume, define
  # o upstream e as regras de proxy; o healthcheck pode validar uma rota pública.
  # =============================================================================
  nginx:
    # Imagem leve e popular do Nginx (sobre Alpine). Ideal para proxy.
    image: nginx:alpine
    container_name: nginx

    # Mapeia a porta 9999 do host para a 9999 do contêiner — ponto único de acesso.
    ports:
      - "9999:9999"

    # Healthcheck HTTP do Nginx. Observação: este teste usa a variável $$PORT no curl;
    # caso não exista no ambiente do Nginx, ajuste o alvo no seu cenário real.
    healthcheck:
      test: [ "CMD-SHELL", "sleep 2 && curl -f http://localhost:$$PORT/clientes/1/extrato || exit 1" ]
      interval: "5s"
      timeout: "5s"
      retries: 60
      start_period: "60s"

    # Monta o seu arquivo de configuração customizado do Nginx para definir upstream
    # (app1:3001, app2:3002) e regras de proxy (listen 9999, proxy_pass, etc.).
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf

    # Sobe o Nginx somente quando as apps estiverem saudáveis — reduz erros de proxy.
    depends_on:
      app1:
        condition: service_healthy
      app2:
        condition: service_healthy

    # Limites de recursos do proxy — úteis em testes com ambiente restrito.
    deploy:
      resources:
        limits:
          cpus: "0.2"
          memory: "100MB"

    restart: always             # Política de reinício automática: se o container parar/crashar, o Docker tenta subir novamente.

# =======================================================================================
# VOLUMES — DECLARAÇÃO GLOBAL
# Aqui declaramos o volume “pgdata”, que é a “gaveta” onde o Postgres guarda os dados.
# O comando `docker compose down -v` apaga essa gaveta (e os dados). Sem `-v`, só
# derruba os contêineres e os dados permanecem para a próxima subida.
# =======================================================================================
volumes:
  pgdata:
